package com.wt.leanbackutil.player;

/**
 * @author junyan
 *         播放状态
 */
public enum PlayState {
    /**
     * 当使用new()方法创建一个MediaPlayer对象或者调用了其reset()方法时，
     * 该MediaPlayer对象处于idle状态。这两种方法的一个重要差别就是：
     * 如果在这个状态下调用了getDuration()等方法（相当于调用时机不正确），
     * 通过reset()方法进入idle状态的话会触发OnErrorListener.onError()，
     * 并且MediaPlayer会进入Error状态；如果是新创建的MediaPlayer对象，
     * 则并不会触发onError(),也不会进入Error状态。
     */
    IDLE,
    /**
     * 这个状态比较简单，MediaPlayer调用setDataSource()方法就进入Initialized状态，
     * 表示此时要播放的文件已经设置好了。
     */
    INITIALIZED,
    /**
     * 主要是和prepareAsync()配合，如果异步准备完成，会触发OnPreparedListener.onPrepared()，进而进入Prepared状态。
     */
    PREPARING,
    /**
     * 初始化完成之后还需要通过调用prepare()或prepareAsync()方法，这两个方法一个是同步的一个是异步的，
     * 只有进入Prepared状态，才表明MediaPlayer到目前为止都没有错误，可以进行文件播放
     */
    PREPARED,
    /**
     * 显然，MediaPlayer一旦准备好，就可以调用start()方法，这样MediaPlayer就处于Started状态，
     * 这表明MediaPlayer正在播放文件过程中。可以使用isPlaying()测试MediaPlayer是否处于了Started状态。
     * 如果播放完毕，而又设置了循环播放，则MediaPlayer仍然会处于Started状态，类似的，
     * 如果在该状态下MediaPlayer调用了seekTo()或者start()方法均可以让MediaPlayer停留在Started状态。
     */
    STARTED,
    /**
     * Started状态下MediaPlayer调用pause()方法可以暂停MediaPlayer，从而进入Paused状态，
     * MediaPlayer暂停后再次调用start()则可以继续MediaPlayer的播放，转到Started状态，
     * 暂停状态时可以调用seekTo()方法，这是不会改变状态的。
     */
    PAUSED,
    /**
     * Started或者Paused状态下均可调用stop()停止MediaPlayer，而处于Stop状态的MediaPlayer要想重新播放，
     * 需要通过prepareAsync()和prepare()回到先前的Prepared状态重新开始才可以。
     */
    STOPPED,
    /**
     * 文件正常播放完毕，而又没有设置循环播放的话就进入该状态，并会触发OnCompletionListener的onCompletion()方法。
     * 此时可以调用start()方法重新从头播放文件，也可以stop()停止MediaPlayer，或者也可以seekTo()来重新定位播放位置。
     */
    PLAYBACK_COMPLETED,
    /**
     * 如果由于某种原因MediaPlayer出现了错误，会触发OnErrorListener.onError()事件，此时MediaPlayer即进入Error状态，
     * 及时捕捉并妥善处理这些错误是很重要的，可以帮助我们及时释放相关的软硬件资源，也可以改善用户体验。
     * 通过setOnErrorListener(android.media.MediaPlayer.OnErrorListener)可以设置该监听器。
     * 如果MediaPlayer进入了Error状态，可以通过调用reset()来恢复，使得MediaPlayer重新返回到Idle状态。
     */
    ERROR,
    /**
     * 通过release()方法可以进入End状态，只要MediaPlayer对象不再被使用，就应当尽快将其通过release()方法释放掉，
     * 以释放相关的软硬件组件资源，这其中有些资源是只有一份的（相当于临界资源）。
     * 如果MediaPlayer对象进入了End状态，则不会在进入任何其他状态了。
     */
    END
}